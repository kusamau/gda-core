bashlog debug "gda_servers_core" "Entered"
TARGET=""
DEBUG=""

# read the GDA9 specific params
for word in "$@"; do
    case $word in
        --devel|--release|--snapshot)
            TARGET=${word}
            ;;
        --debug)
            DEBUG=${word}
            ;;
        *)
            continue
            ;;
    esac
done

if [[ "${GDA_MODE}" == "live" && "${CONTROL_MACHINE_NAME}" != "$(uname -n)" ]]; then
    # This section runs when in live mode when not on the control machine
    # i.e. it initiates the ssh tunnel to call remotestartupscript.sh on the control machine.
    # This will throw away the environment built up so far, and then go back through beamline's
    # gda bash script, rebuilding the environment and then sending execution through the else below.

    if [[ -n "${GDA_IN_REMOTE_STARTUP-}" ]]; then
        bashlog error "gda_servers_core" "Internal error: remote startup loop detected"
        exit 2
    fi
    # The name generated for GDA_LOG_FILE ends with a timestamp
    # When starting in live mode, two filenames are generated (one on workstation, one on control machine by userid gda2)
    # Ensure that at least one second passes before we generate a new name on the control machine, to ensure uniqueness
    # This is required because the two files are created by different users, and a name collision results in permissions problems.
	sleep 1

    # Validate environment variables
    for env_var_name in CONTROL_MACHINE_USER CONTROL_MACHINE_NAME CONTROL_MACHINE_SSHKEY_LOC; do
        bashlog debug "gda_servers_core" "\${${env_var_name}}=${!env_var_name-NOT.SET.OR.NULL}"
        if [ -z "${!env_var_name+x}" ]; then
            bashlog error "gda_servers_core" "\${${env_var_name}} is not set (or is null) - exiting"
            exit 2
        fi
    done

    # To prevent man-in-the-middle attacks, ensure that we use a validated host key
    CONTROL_MACHINE_PUBKEY_FILE=${GDA_VAR}/.ssh/$BEAMLINE-host.key.pub
    if [[ -f $CONTROL_MACHINE_PUBKEY_FILE ]]; then
      if [[ -n "${CONTROL_MACHINE_PUBKEY-}" ]]; then
        bashlog info "gda_servers_core" "Public key file $CONTROL_MACHINE_PUBKEY_FILE exists, overriding CONTROL_MACHINE_PUBKEY"
      fi
      CONTROL_MACHINE_PUBKEY="$(<$CONTROL_MACHINE_PUBKEY_FILE)"
    fi
    CONTROL_MACHINE_NAME_FQDN=${CONTROL_MACHINE_NAME%.diamond.ac.uk}
    CONTROL_MACHINE_IP=$(resolveip -s $CONTROL_MACHINE_NAME)
    CONTROL_MACHINE_IP=${CONTROL_MACHINE_IP%% }
    if [[ -n "${CONTROL_MACHINE_PUBKEY-}" ]]; then
      if [[ -f ~/.ssh/known_hosts ]]; then
        ssh-keygen-remove() {
	        bashlog debug "gda_servers_core" "removing old public key for $1 in ~/.ssh/known_hosts"
	        SSH_KEYGEN_OUT=$(ssh-keygen -R $1)
	        bashlog debug "gda_servers_core" "removed old public key for $1 in ~/.ssh/known_hosts: $SSH_KEYGEN_OUT"
        }
        # Only try to remove old key if known_hosts exists, otherwise ssh-keygen failing will return us to the command line.
        ssh-keygen-remove ${CONTROL_MACHINE_NAME}
        # Also remove the short name of the control server, it it exists
        ssh-keygen-remove ${CONTROL_MACHINE_NAME_FQDN}
        # And remove the numeric IP address of the server, if it has an entry
        ssh-keygen-remove ${CONTROL_MACHINE_IP}
      fi
      bashlog debug "gda_servers_core" "adding new public key for ${CONTROL_MACHINE_NAME} in ~/.ssh/known_hosts"
      echo "${CONTROL_MACHINE_NAME_FQDN},${CONTROL_MACHINE_NAME},${CONTROL_MACHINE_IP} ${CONTROL_MACHINE_PUBKEY}" >> ~/.ssh/known_hosts
    else
      bashlog warn "gda_servers_core" "Public key file $CONTROL_MACHINE_PUBKEY_FILE doesn't exist and no CONTROL_MACHINE_PUBKEY defined!"
    fi

    ssh -T -o BatchMode=yes -i ${CONTROL_MACHINE_SSHKEY_LOC} ${CONTROL_MACHINE_USER}@${CONTROL_MACHINE_NAME} ${GDA_OPERATION} ${TARGET} ${DEBUG} &
    export SERVERS_SSH_PID=$!
    # Due to the problem with ssh where remotestartupscript.sh completes, but
    # ssh doesn't return, we run ssh in background but record its PID in
    # SERVERS_SSH_PID. This allows the calling scripts to use lookForFile and
    # wait for either the ssh command completing (fast, but unreliable), or
    # the OBJECT_SERVER_STARTUP_FILE appearing (slow, but reliable). Note that
    # due to network filesystem issues, waiting for the file client side is
    # *much* less responsive but should start the client eventually, even if
    # ssh hangs.

else
    # This runs when live on the control machine or in any mode other than live
    # i.e. when starting in live from a beamline workstation, execution will eventually come
    # through here when it has been through the ssh tunnel loop.

    echo
    case "${GDA_OPERATION,,}" in
        stop) echo "Stopping the GDA Server, please wait..." ;;
        start|restart) echo "${GDA_OPERATION^}ing the GDA Server, please wait...";; # ^ converts 1st character to upper case
        *) echo "Restarting the GDA Server, please wait..." ;; # if no stop|start|restart was passed to this script, then restart is assumed
    esac

    # At this point, the pre scripts must have set GDA_LOGS_DIR and GDA_VAR
    #TODO check that

    # Set up the directory for VAR
    mkdir -pv -m 777 ${GDA_VAR}

	if [[ -f "${OBJECT_SERVER_STARTUP_FILE}" ]]; then
	    bashlog info "gda_servers_pre_facility" "deleting ${OBJECT_SERVER_STARTUP_FILE}, last modified $(stat --format=%y ${OBJECT_SERVER_STARTUP_FILE} | cut -c 1-19)"
	    rm -fv ${OBJECT_SERVER_STARTUP_FILE}
	fi

    umask 0002
    # This should fix a problem where sub-directories created in a visit folder end up
    # with a different mask to the default.
    GDA_TARGET_SCRIPT=$(readlink -f ${GDA_WORKSPACE_PARENT}/${GDA_CORE_CONFIG_rel}/bin/gda_target.sh)

    export JAVA_OPTS="-Dgda.deploytype=1 -XX:MaxPermSize=1024m" # Seems to fix the reset_namespace problem

    if [[ -n ${DEBUG-} ]]; then
    	echo "Awaiting debugger connection on port 8000"
    fi

    bashlog debug "gda_servers_core" "Starting ${GDA_TARGET_SCRIPT}  ${GDA_OPERATION} ${TARGET} ${DEBUG}"
    nohup ${GDA_TARGET_SCRIPT} ${GDA_OPERATION} ${TARGET} ${DEBUG} >> ${GDA_LOG_FILE}  2>&1 &


    if [[ ${GDA_OPERATION,,} != "stop" ]]; then
        # Starting; wait for the startup file to be created so that any
        # gda_servers_post scripts don't run before the servers are started.

        ${GDA_WORKSPACE_PARENT}/${GDA_FACILITY_CONFIG_rel}/bin/utils/lookForFile $OBJECT_SERVER_STARTUP_FILE $HOSTNAME
        echo
        echo "GDA Server started"

        # TODO: Ideally we would like to stop waiting for the startup file if the startup fails, but all
        #       output from the gda core script is written to the log file and not returned from nohup.
        #       We never find out the exit codes or process status and failed startups will continue to
        #       wait for this file until a subsequent start of the GDA servers works.
    else
        echo
        echo "GDA Server stopped"
    fi
fi

bashlog debug "gda_servers_core" "Exited"
